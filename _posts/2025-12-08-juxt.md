---
layout: post
title: "Juxt"
date: 2025-12-08
---

## Juxt

As I get deeper into this component that swings around a lot of data, then 
slices and dices it in varous ways, I've been finding managing the data structure a bit cumbersome. 

I had to go source a good deal of data that's related to each other, but maybe not
necessarily connected directly. And then I want to pass it on in some organized fashion 
and not have to do the database pulls at every lower level component step if I have 
access to it all in the parent. 

So, I found myself building a bit of a super map of the data I wanted to pass down 
so that it would be structured in a way that was useful and still didn't require a 
dozen parameters and then I got ambitious and though, boy wouldn't it be nice 
if it was already in the order that I wish it was in so then my child components 
could be dead simple and populated by for loops! 

But.. then I tried to figure out how to sort map data by all the ways I wanted 
it to be clustered. Stories in iterations, yes, and iterations in their projects, 
but iterations (and their stories) ordered by iteration end date. Ok, easy enough. 

But, then I also want the projects ordered by iteration end date. Oh, and if they're 
tied, then I want them sorted by when the user last entered (which is on an entirely different 
entity that's only used for this and for one other thing). 

Right, and then I want to display the projects that don't have any active iterations, 
and all the ones that have been set to minimize (the one other thing) below the 
others, but still in urgency order.
I don't know about you, but that was enough to make my head spin. 

I could pull out the iteration-end dates from each iteration, and I could 
figure out for the project which of the active iterations had the soonest date. 
And I could, with enough massaging, figure out if a project should be minimized or not. 

It can be done of course, you can give the sort function to determine how to 
compare two values (they need to be comparable, or implement the ICompareable protocol 
according to cljs.core). 
But.. there's something better! Especially if you already have ways to access 
what you want compared! 

```
(defn juxt 
    "Takes a set of functions and returns a fn that is the juxtaposition
      of those fns.  The returned fn takes a variable number of args, and
      returns a vector containing the result of applying each fn to the
      args (left-to-right).
      ((juxt a b c) x) => [(a x) (b x) (c x)]"
```

Ok, so if I want to evaluate my project list first by iteration end-date, and then 
by last-entered-date, if I can get those two things into the data set that's being orderd, 
I think I can pull this off! 

But wait, I don't want two sets of data, I just want one, single, sorted list. 
That's not what the output of the example in the juxt docs looks like though. 

Have no fear, our old friend sort-by is here! 

You can call sort-by with a key-function, and a collection (you can also specify the 
comparison function, but if your data is already comparable, then you're ok). 

From the docs, what sort-by does: 
```
(defn sort-by
  ([keyfn coll]
   (sort-by keyfn compare coll))
  ([keyfn comp coll]
       (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))
```

So, what if we use juxt to provide the key function? 

It turns out we can use juxt to provide a series of sort orders! 

```
    (def students [{:name "Alice" :grade "A"}
                   {:name "Bob" :grade "B"}
                   {:name "Charlie" :grade "A"}])

    (sort-by (juxt :grade :name) students)
        => ({:name "Alice", :grade "A"} {:name "Charlie", :grade "A"} {:name "Bob", :grade "B"})
```
And, likewise, I can sort my projects by iteration end-date, and then if those are 
the same, I can sort it by when the project was last entered. And, if I came up with 
more tie-breakers, I could just keep adding them to my key list!


**Cheers!**