---
layout: post
title: "Fail"
date: 2025-11-14
---

## Fail

An unlikely, but entertaining functionality was brought to my attention that I discovered today. 

I had been working on adding functionality to how failed tests were rendered in our CLI program. There 
was already a default failure message, but we wanted specific behavior to occur if the test failed due 
to it timing out, and different behavior if the user's program crashed (and then, of course, the prior 
behavior should continue on all other typical failures). 

Our code initially was something like: 

```clojure
(loop [failing-tests failing-tests num-fail-assertions 0]
      (if (empty? failing-tests)
        num-fail-assertions
        (do (render-assertion-failures x y z)
            (recur (rest failing-tests) (inc num-fail-assertions)))))
```
and I started adding tests to check for behavior for my new conditions and changing my code just enough to get the test 
to pass (while making sure my original tests for the render regular assertion failures continued to pass as well,
 of course!) 

Gradually, I swapped up that do (not actually a do) with a cond that looked a little like:

```clojure
(cond (= state :timed-out) (render-timed-out x y z)
      (= state :crashed) (render-crashed x)
      :fail (render-assertion-failures x y z))
```
All of my tests passed, and, a little test run or two by hand just to admire my handiwork on the print messages, 
all looked good. So.. the tests pass, so the code shipped! 

You might have noticed what I didn't, which is that `:fail` isn't usually used like that! But, it funcionally worked 
just as if it had correctly been an `:else`!

I guess there are some rare occasions that you have to change your code, even if all your tests are passing.

**Happy Friday!**