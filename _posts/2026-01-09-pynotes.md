---
layout: post
title: "Pynotes"
date: 2026-01-09
---

## Python notes

Back to trying to drink from the firehose. 
It's been a pretty weird day and I can't quite figure out what to think or what to do with this strange and heavy mix 
of emotions. It makes it particularly challenging to remain focused, and I know I definitely need to do that. 

I haven't gotten my first project even started up yet, but I've been skimming through the [documentation](https://docs.python.org/3/tutorial/index.html) 
to try to get some bearings and there are some cool notes:

You can give negative indicies to strings to count from the right
```jupyter
word = 'python'
word[-1] = n


list= [1, 4, 9]
list[0] = 1
list[-1] = 9

list[0] = 2
list = [2, 4, 9]
```
assignment of a list is just a pointer to the same list, 
to get a new list, you must split the list!
```jupyter
rgb = ["Red", "Green", "Blue", "Alph"]
rgba = rgb
id(rgb) == id(rgba)

correct_rgba = rgba[:]  #<- this 'splits' the list, but takes it all
correct_rgba[-1] = "Alpha"
correct_rgba
["Red", "Green", "Blue", "Alpha"]
rgba
["Red", "Green", "Blue", "Alph"]

len(rgba) = 3

a = ['a', 'b', 'c']
n = [1, 2, 3]
x = [a, n]
x
[['a', 'b', 'c'], [1, 2, 3]]
x[0]
['a', 'b', 'c']
x[0][1]
'b'

```
There can be 0 or more elif, else is optional
Option to investigate: match statements
```jupyter
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case 401 | 403 | 404:
            return "Not allowed"
        case _:
            return "Something's wrong with the internet"
```
_ is a wildcard variable, mu

```jupyter
x = int(input("Please enter an integer: "))
Please enter an integer: 42
if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
    
    
    words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))

cat 3
window 6
defenestrate 12
```


```jupyter
list(range(0, 10, 3))
[0, 3, 6, 9]

a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])

0 Mary
1 had
2 a
3 little
4 lamb
```
Range is not a list! it is iterable

Classes are back in
```jupyter
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
```
functions are too:
```jupyter
def fib(n):
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```
matching cases: 

```jupyter

class Point:
    __match_args__ = ('x', 'y')
    def __init__(self, x, y):
        self.x = x
        self.y = y

match points:
    case []:
        print("No points")
    case [Point(0, 0)]:
        print("The origin")
    case Point(x, y) if x == y:
        print(f"Y=X at {x}")
    case Point(x, y):
        print(f"Single point {x}, {y} not on diagonal")
    case [Point(0, y1), Point(0, y2) as p2]:
        print(f"Two on the Y axis at {y1}, {y2}")
    case _:
        print("Something else")

from enum import Enum
class Color(Enum):
    RED = 'red'
    GREEN = 'green'
    BLUE = 'blue'

color = Color(input("Enter your choice of 'red', 'blue' or 'green': "))

match color:
    case Color.RED:
        print("I see red!")
    case Color.GREEN:
        print("Grass is green")
    case Color.BLUE:
        print("I'm feeling the blues :(")
```
"The execution of a function introduces a new symbol table used for the local variables of the function. 
More precisely, all variable assignments in a function store the value in the local symbol table; 
whereas variable references first look in the local symbol table, then in the local symbol tables of 
enclosing functions, then in the global symbol table, and finally in the table of built-in names. 
Thus, global variables and variables of enclosing functions cannot be directly assigned a value within 
a function (unless, for global variables, named in a global statement, or, for variables of enclosing 
functions, named in a nonlocal statement), although they may be referenced."

"The actual parameters (arguments) to a function call are introduced in the local symbol table of the 
called function when it is called; thus, arguments are passed using call by value (where the value is 
always an object reference, not the value of the object). When a function calls another function, 
or calls itself recursively, a new local symbol table is created for that call."

Functions without a return statement return 'None'; normally not printed, but you could print 
it by printing the function call.


Classes are dynamic; created at runtime and can then be modified. 
```jupyter
class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart

x = Complex(3.0, -4.5)
x.r, x.i
(3.0, -4.5)
```
__init__ is optional, and it having params is optional. 
Instance objects; have attributes and methods. (must already be defined in the class)

You can store methods from a class in a variable and then call it later
```jupyter
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'
       
x = MyClass()
xf = x.f
while True:
    print(xf())
```
Class variables vs instance-variables
```jupyter
class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance
```
Oohh, I like this default argument values!! (And I already think I might have a use for 
a function very much like this!)
```jupyter
def ask_ok(prompt, retries=4, reminder='Please try again!'):
    while True:
        reply = input(prompt)
        if reply in {'y', 'ye', 'yes'}:
            return True
        if reply in {'n', 'no', 'nop', 'nope'}:
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('invalid user response')
        print(reminder)
```
- giving only the mandatory argument: ask_ok('Do you really want to quit?')

- giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2)

- or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')

### Looping: 
Retrieving both keys & values: 
```jupyter
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.items():
    print(k, v)

gallahad the pure
robin the brave
```
Retrieving both index & value: 
```jupyter
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)

0 tic
1 tac
2 toe
```
(You can just call enumerate on a container to make this magic happen!!)


### Iterators
```jupyter
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one':1, 'two':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
```
Most containers have a iter() funciton that returns an iterator object that has a __next__() method
that lets you access one element of the container at a time, until there are none left and you get 
a `StopIteration` exception that ends the for loop. 
A sneaky look under the hood: 
```jupyter
s = 'abc'
it = iter(s)
it
<str_iterator object at 0x10c90e650>
next(it)
'a'
next(it)
'b'
next(it)
'c'
next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

**Happy Friday?**