---
layout: post
title: "Wire"
date: 2025-08-06
---

## Wire from c3kit


So you want to build some front-end code, naturally, you're going to want 
to be able to test it! 

Reagent does have some ability to test  your rendered page. 

You'll `:require [reagent.core :as r] [reagent.dom :as rdom]`
Before you can test your code, you'll first need to render it. You could 
render just a single component at a time that you're testing: 

````
(let [container (.createElement js/document "div")]
    (.appendChild (.-body js/document) containter)
    (rdom/render [target-component] container)
````
This puts our target component in the div within the body
````
<body>
    <div>
        [target-component]
    </div>
</body>
````
Then we can finally get to the work of the test!
Let's say our target component has a table with some trs that contain 
td elements and we want to verify that they all showed up.

````
(let [all-tds (.querySelectorAll containter "td")]
    (should= 9 (.-length all-tds)))
````
And then, to clean up our environment, we need to unmount our test 
structure before we can move on to the next: 
````
(.removeChild (.-body js/document) containter))
````

This is all kind of a lot. It's doable, but fairly hands-on. Enter, c3kit 
Wire! 

All the set up and tear down are implemented for you in a single command
listed under your describe:
`(wire/with-root-dom)` implements before and after methods to create a DOM
with a root and then clean up anything attached to it. 


They thought you might want to be able to select and they of course know 
you want to select from your container, and they even have an option to 
tidy up your counting!

````
(should-select ".in-progress-class")
(should= 9 (wire/count-all "td.empty"))
````
You can write single line tests that clearly state that when this component
is rendered, it should be able to select node item with a class of .in-progress. 
You should also be able to find 9 nodes of td with a class of empty.
Your tests pass if it does, and it fails if it doesn't. Easy. 

You don't have to fuss with the under-the-hood work of 
to get javascript's version of: `root.querySelectorAll(selector)`
into clojure-script with `(js-invoke root "querySelectorAll" selector`
 and _then_ parsing the list of nodes that you get back into an array 
that you can use! 

It's totally possible; you can use call to essentially 
borrow a method from another class to use on your class if it has enough 
similar features that it can work. In this case, the node list still has 
a length and indexed values, and that's what you extract by calling 
Array's slice method on the node list using call `Array.prototype.slice.call(nodeList)`
or, to our Clojure example: `(js-invoke js/Array.prototype.slice "call" nodeList)`

So, all together it'd be:
````
(defn select-all [root selector]
    (let [results (wjs/query-selector-all root selector)
             slice   #(js-invoke js/Array.prototype.slice "call" %)]
         (into [] (slice results)))
         
(count (select-all root selector))   
````

Or... You could just use c3kit/wire and have easy peasy testing abilities that help 
navigate the DOM and make front end testing so much more approachable!


**Cheers!**