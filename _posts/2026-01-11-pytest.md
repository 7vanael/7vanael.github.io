---
layout: post
title: "Pytest"
date: 2026-01-11
---

## Testing in Python
Ok, so I can get some code to run, and that's great, but now I definitely need to understand my testing options. 

Python does have some baked in testing, but the internet seemed to agree that pytest was a popular favorite. 

```jupyter
import pytest
from board import Board
from console import render_board, render_welcome


def test_print_output(capsys):
    render_welcome()
    captured = capsys.readouterr()
    assert captured.out == 'Welcome to Tic-Tac-Tython!\n Let\'s begin:  \n'
```
So, you can write simple test functions `def` with names (I felt like this was almost back to writing tests in Java agian)
And then, the similar setup of arrange (if any), act and assert. 

I found a little helper, capsys (capture system out - though I think it could make a comeback for sys in!) that 
seemed like my good stand in for (with-out-string). And then, a plain old assert and then your boolean expression. 
It's interesting to note the difference here, it's always just assert, and then you write almost any assertion you want. 
There aren't multiple expressions like `(should-be-nil)` or `(should-include)` etc. It's just assert, and then you 
write the expression yourself `assert 'X' in board.cells` or `assert 4 not in board.available_moves()`
I kinda like the simplicity that still provides extensibility. 


You do have the option of creating test classes. It seems like these are almost used as Contexts. I haven't gotten 
too far into them yet, but for simple assertions in pytest they're optional. They can be used to group similar tests 
together and they can be used to initialize the setup with a setup function: 
```jupyter
class TestGame:
    def setup_method(self):
        self.board = Board()
        self.game = Game(self.board)
    
    def test_new_board_has_9_empty_cells(self):
        board = Board()  <- Now the tests can get rid of this line! Booo code duplication
        assert len(board.cells) == 9
        assert all(cell == Board.EMPTY for cell in board.cells)
```

One exception to Test Classes being optional is if using unittest- one of the built in features in python. 
Unittest is the first way I've found so far to be able to have light mocks. I'm thinking this will be the substitute
for when I wish I had a `(stub)` and could call `should-have-invoked`

So, to just test what my paltry main function does at the moment (no, we're not done, I know, it's not going 
to stay like this): 
```jupyter
from board import Board     <- patches DON'T point here
from console import render_welcome, render_board

def main():
    render_welcome()        <- patches point here!
    board = Board()
    render_board(board)
```

```jupyter
class TestMain(unittest.TestCase):
    @patch('main.Board')                <- the path to where the function CALL is, not where the function lives!
    @patch('main.render_board')         <- these are all called inside the main function, 
    @patch('main.render_welcome')       <- these can be used for all the tests in the class, not just the next one!
    
    def test_main_calls_functions(self, mock_welcome, mock_render_board, mock_board_class):
        mock_board_instance = mock_board_class.return_value

        main()

        mock_welcome.assert_called_once()
        mock_board_class.assert_called_once()
        mock_render_board.assert_called_once_with(mock_board_instance)
```
Ok, the hardest part for me to get my head around with this was, what in the heck is `mock_welcome` and where is it 
coming from? I don't see `mock_welcome` anywhere else on the page, so how could these asserts possibly assert anything 
because we just invented a variable with no definition!!

Right, I see you. And, once I understood this next part, I want you to know I join you in your hatred for it. 
The parameters are positional based on the **_INVERSE_** order of the _@PATCHES_. 
Our last patch was `main.render_welcome`, so that's going to define the first argument (other than self, which is always 
the first argument to a class's method). We could call it anything. The wiring is positional. 

Need to add another patch? Did you put a patch in early that most of your tests don't need? Well I hope you are either 
going to be fine with a ton of variables you don't need, or re-writing every function call when you want to modify that 
list of patches. 

Shall we all just have a primal scream over it? Just me? Ok, that's fine. 


## Combos?

Ok, hold on, more testing framework breakthroughs. 
Firstly, I decided that I'm not going to do the terrible win evaluation that I did last time. It was cool, it was 
fine, but it was a lot of work to have it go through and calculate all of the diagonals, and being board size agnostic 
by the end, and so maybe the combos were a length of 3, but maybe a length of 4, it was cool that I got there, but 
I've seen how Ralex wrote tic tac toe for the CLI, and my friend just used a list of what the wins were. Brilliant. 
Simple. So so so much shorter to code. 

Great, but then I want to test all of the winning combinations; this will let me demonstrate what the winning 
combinations should be, and that they result in a win. But.. that's still a lot of individual tests, right? 
So, off I go to the internet to find out, how can I do something like a for loop for my tests? 
Turns out, you can [parametrize](https://docs.pytest.org/en/stable/how-to/parametrize.html) them. 
There are a lot of options listed here, maybe too many, but, it lets you run a for loop. And then, it lets you do nested 
for loops. Check it out:
```jupyter
@pytest.mark.parametrize("combo", Board.WIN_COMBINATIONS)
@pytest.mark.parametrize("player", [Board.PLAYER_X, Board.PLAYER_O])
def test_all_winning_combinations(self, board, combo, player):
    a, b, c = combo
    board.cells[a] = player
    board.cells[b] = player
    board.cells[c] = player
    assert board.winner() == player
```
Running just that test got me 16 test runs!
```jupyter
test_board.py::TestWinner::test_all_winning_combinations[X-combo0] PASSED [  6%]
test_board.py::TestWinner::test_all_winning_combinations[X-combo1] PASSED [ 12%]
test_board.py::TestWinner::test_all_winning_combinations[X-combo2] PASSED [ 18%]
[...]
test_board.py::TestWinner::test_all_winning_combinations[O-combo6] PASSED [ 93%]
test_board.py::TestWinner::test_all_winning_combinations[O-combo7] PASSED [100%]
```

Sweet.

Ok, more unittest.mock goodness: return_value, and even better, side_effect. You want to test user input
validation? Yes. You want to test manually? No! You want to test multiple things in one test?? Of course!

Ok, this part is even better than the redefs, {:return } option in clojure. 

```jupyter
with patch('builtins.input', return_value='5'):
    print(input())  -> '5'
    print(input())  -> '5'
    print(input())  -> '5'
```
You can set up a patch that essentially stubs stdin and just have it always return the same thing every time. 

Or, you can get methodical and demonstrate multiple input attempts in the same test like: 
```jupyter
with patch('builtins.input', side_effect=['-1', '10', '5']):
    print(input())  -> '-1'
    print(input())  -> '10'
    print(input())  -> '5'
```
Maybe I was doing it wrong, but I distinctly remember struggling over getting an atom to hold a function that changed 
it's output by counting how many times it had been called. It was not cute. This on the other hand... pretty darn clear!

This is going to be great for testing user-input, and for runing full-game tests. 
It even looks like you could assign the side_effect to be a function instead of just a set list, so that 
could get even more crazy. But I think that's a future issue. 


**Cheers!**