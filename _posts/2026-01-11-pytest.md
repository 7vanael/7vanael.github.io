---
layout: post
title: "Pytest"
date: 2026-01-11
---

## Testing in Python
Ok, so I can get some code to run, and that's great, but now I definitely need to understand my testing options. 

Python does have some baked in testing, but the internet seemed to agree that pytest was a popular favorite. 

```jupyter
import pytest
from board import Board
from console import render_board, render_welcome


def test_print_output(capsys):
    render_welcome()
    captured = capsys.readouterr()
    assert captured.out == 'Welcome to Tic-Tac-Tython!\n Let\'s begin:  \n'
```
So, you can write simple test functions `def` with names (I felt like this was almost back to writing tests in Java agian)
And then, the similar setup of arrange (if any), act and assert. 

I found a little helper, capsys (capture system out - though I think it could make a comeback for sys in!) that 
seemed like my good stand in for (with-out-string). And then, a plain old assert and then your boolean expression. 
It's interesting to note the difference here, it's always just assert, and then you write almost any assertion you want. 
There aren't multiple expressions like `(should-be-nil)` or `(should-include)` etc. It's just assert, and then you 
write the expression yourself `assert 'X' in board.cells` or `assert 4 not in board.available_moves()`
I kinda like the simplicity that still provides extensibility. 


You do have the option of creating test classes. It seems like these are almost used as Contexts. I haven't gotten 
too far into them yet, but for simple assertions in pytest they're optional. They can be used to group similar tests 
together and they can be used to initialize the setup with a setup function: 
```jupyter
class TestGame:
    def setup_method(self):
        self.board = Board()
        self.game = Game(self.board)
    
    def test_new_board_has_9_empty_cells(self):
        board = Board()  <- Now the tests can get rid of this line! Booo code duplication
        assert len(board.cells) == 9
        assert all(cell == Board.EMPTY for cell in board.cells)
```

One exception to Test Classes being optional is if using unittest- one of the built in features in python. 
Unittest is the first way I've found so far to be able to have light mocks. I'm thinking this will be the substitute
for when I wish I had a `(stub)` and could call `should-have-invoked`

So, to just test what my paltry main function does at the moment (no, we're not done, I know, it's not going 
to stay like this): 
```jupyter
from board import Board     <- patches DON'T point here
from console import render_welcome, render_board

def main():
    render_welcome()        <- patches point here!
    board = Board()
    render_board(board)
```

```jupyter
class TestMain(unittest.TestCase):
    @patch('main.Board')                <- the path to where the function CALL is, not where the function lives!
    @patch('main.render_board')         <- these are all called inside the main function, 
    @patch('main.render_welcome')       <- these can be used for all the tests in the class, not just the next one!
    
    def test_main_calls_functions(self, mock_welcome, mock_render_board, mock_board_class):
        mock_board_instance = mock_board_class.return_value

        main()

        mock_welcome.assert_called_once()
        mock_board_class.assert_called_once()
        mock_render_board.assert_called_once_with(mock_board_instance)
```
Ok, the hardest part for me to get my head around with this was, what in the heck is `mock_welcome` and where is it 
coming from? I don't see `mock_welcome` anywhere else on the page, so how could these asserts possibly assert anything 
because we just invented a variable with no definition!!

Right, I see you. And, once I understood this next part, I want you to know I join you in your hatred for it. 
The parameters are positional based on the **_INVERSE_** order of the _@PATCHES_. 
Our last patch was `main.render_welcome`, so that's going to define the first argument (other than self, which is always 
the first argument to a class's method). We could call it anything. The wiring is positional. 

Need to add another patch? Did you put a patch in early that most of your tests don't need? Well I hope you are either 
going to be fine with a ton of variables you don't need, or re-writing every function call when you want to modify that 
list of patches. 

Shall we all just have a primal scream over it? Just me? Ok, that's fine. 

**Cheers!**