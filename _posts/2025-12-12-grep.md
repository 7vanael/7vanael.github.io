---
layout: post
title: "Grep"
date: 2025-12-12
---

## Grep

So I took on a story that was supposed to be quick and easy, take code that was duplicated in several projects, move it 
to one of our libraries so it could be just imported and eliminate duplicate code. The code already existed, there 
were examples of how to do it, it was going to be easy and fast. Done by lunch I bet with room to do other work in the 
afternoon! 

Well, permissions issues aside, it took just a little going to get it done, but I was happy with the update to the 
library. Then, just some quick updates to the main file in three projects (and, creating a spec file for one that 
somehow had never been created before, and then of course creating as many tests as I could for the code that was 
already there), check they all run, push and done!

It was great, it only took mildly longer than expected, but it was fine. 

8 minutes later, I got a call from a teammate that they couldn't run the primary project. Yikes. 
Ok, troubleshooting time. 

Thankfully, my changes weren't actually the reason they couldn't run, but they did uncover how the difference in use 
between running migrations, and just syncing the migrations can really confuse your database. (A word to the wise, 
it's better to troubleshoot the migration than get your database out of sync with them, which is, confusingly the result 
of superfluous migrate sync command usage).  However, it was then brought to my attention that, in order for the service 
to actually be able to run the migrations, the migration files had to be deployed in the source code, not in the dev folder. 
The dev folder was fine while github actions is responsible for it, but now if we're moving toward having the application 
in Kubernetes running the migrations... they need to be in production code. Ok, that isn't too bad, that's just moving a 
folder, easy. 

But wait. Some of those complex migrations had specs written with them. And, since they were in the dev folder, there 
wasn't a clear system for where else they ought to go, so they were just added to the bottom of the file. Which is fine! 
Until I move them into the source code. 

Ok, so now I have 80-some files of migrations, but only some of them have specs that I need to address. Shall I open 
them all, one by one, to manually inspect if it contains a "describe" block? No. That would be silly. (Ok, we did it). 
And it would be error prone! (We identified 8... there were actually 11). 

This is a great time for [grep](https://www.reddit.com/r/linux/comments/1cq86yr/grep_cheatsheet/). 
Global Regular Expression (search) Print. 
Yep, that's what we want! Figure out your command, your path and your regex, and off you go! 
Then I get a list of all the files that have what I'm looking for (and it's much more accuate than 
hand counting)!

Ok.. Now I just need Grep to split the files, update the specs, pull the 
functions for the specs into a spec file and add a :migration tag so they 
don't run with the rest of our specs and that'll be done all lickety-split? 

I don't see that command on the list so... back to it for me! (so much for the one point story!)


**Happy Friday!**